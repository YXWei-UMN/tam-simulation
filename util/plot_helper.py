import ast
import re

'''
plot_helper provides some helper functions that parse information from log files generated by TAM simulation.
Useful for plotting simulation results.
Note: if you change the log format, then some functions might break.
'''


def plot_time_value_list(subplt, time_value, label):
    """

    :param subplt: pyplot axes object
    :param time_value: a list of (time, value) tuple
    :param label: label used in legend
    :return:
    """
    time_list = [time for time, value in time_value]
    value_list = [value for time, value in time_value]
    subplt.plot(time_list, value_list, label=label)


def plot_client_throughput(filename, subplt, ylim=None, pattern=None, time_range=None, show_avg=False):
    """

    :param filename: client_log file
    :param subplt: pyplot axes object
    :param ylim: y-axes range, defaults to [0,1.05*max_throughput]
    :param pattern: only plot clients whose name matches the pattern (in regular expression),
                    defaults to None (plot all clients)
    :param time_range: plot throughput within time_range
    :param show_avg: print average latency in legend
    """

    client_throughput = {}
    max_throughput = 0

    for line in open(filename):
        items = line.split()
        client_name = items[1]
        time = float(items[5])
        if time_range is not None and (time < time_range[0] or time > time_range[1]):
            continue
        throughput = float(items[7])
        if throughput > max_throughput:
            max_throughput = throughput

        if client_name not in client_throughput:
            client_throughput[client_name] = []

        if len(client_throughput[client_name]) > 0 and client_throughput[client_name][-1][0] == time:
            old_throughput = client_throughput[client_name][-1][1]
            new_throughput = throughput + old_throughput
            if new_throughput > max_throughput:
                max_throughput = new_throughput
            client_throughput[client_name][-1] = (time, new_throughput)
        else:
            client_throughput[client_name].append((time, throughput))

    for client_name in client_throughput:
        # noinspection PyUnresolvedReferences
        if pattern is None or pattern.match(client_name):
            label = client_name
            if show_avg:
                avg_throughput = sum([throughput for _, throughput in client_throughput[client_name]]) / len(
                    client_throughput[client_name])
                label += " " + str(round(avg_throughput, 2))
            plot_time_value_list(subplt, client_throughput[client_name], label)

    subplt.set_title("throughput")
    subplt.legend(loc='best')

    if ylim:
        subplt.set_ylim(ylim)
    else:
        subplt.set_ylim([0, max_throughput * 1.05])
    return client_throughput


def plot_client_latency(filename, subplt, ylim=None, pattern=None, time_range=None):
    """

    :param filename: client_log file
    :param subplt: pyplot axes object
    :param ylim: y-axes range, defaults to [0,1.05*max_latency]
    :param pattern: only plot clients whose name matches the pattern (in regular expression),
                    defaults to None (plot all clients)
    :param time_range: plot latency within time_range
    """
    client_latency = {}
    max_latency = 0

    for line in open(filename):
        items = line.split()
        client_name = items[1]
        time = float(items[5])
        if time_range is not None and (time < time_range[0] or time > time_range[1]):
            continue
        latency = float(items[9])
        if latency > max_latency:
            max_latency = latency

        if client_name not in client_latency:
            client_latency[client_name] = []
        client_latency[client_name].append((time, latency))

    for client_name in client_latency:
        # noinspection PyUnresolvedReferences
        if pattern is None or pattern.match(client_name):
            plot_time_value_list(subplt, client_latency[client_name], client_name)

    subplt.set_title("average latency")
    subplt.legend(loc='best')

    if ylim:
        subplt.set_ylim(ylim)
    else:
        subplt.set_ylim([0, max_latency * 1.05])


def plot_resource_utilization(filename, subplt, ylim=None, pattern=None):
    """

    :param filename: resource_log file
    :param subplt: pyplot axes object
    :param ylim: y-axes range, defaults to [0,1.05]
    :param pattern: only plot resources whose name matches the pattern (in regular expression),
                    defaults to None (plot all resources)
    """
    resource_utilization = {}

    for line in open(filename):
        items = line.split()
        res_name = items[1]
        time = float(items[3])
        utilization = float(items[7])

        if res_name not in resource_utilization:
            resource_utilization[res_name] = []
        resource_utilization[res_name].append((time, utilization))

    for res_name in resource_utilization:
        # noinspection PyUnresolvedReferences
        if pattern is None or pattern.match(res_name):
            plot_time_value_list(subplt, resource_utilization[res_name], res_name)

    subplt.set_title("resource utilization")
    subplt.legend(loc='best')

    if ylim:
        subplt.set_ylim(ylim)
    else:
        subplt.set_ylim([0, 1.05])
    return resource_utilization


scheduler_pattern = re.compile(".*scheduler: \[(?P<scheduler>.*)\].*")
fifo_pattern = re.compile("FIFOScheduler .*")
wfq_pattern = re.compile("WFQScheduler queues: (?P<queues>\{.*\})")


def get_scheduler_queue_size(line):
    match = scheduler_pattern.match(line)
    assert match is not None
    scheduler = match.group("scheduler")
    fifo_match = fifo_pattern.match(scheduler)
    if fifo_match is not None:
        return {}
    wfq_match = wfq_pattern.match(scheduler)
    if wfq_match is not None:
        return ast.literal_eval(wfq_match.group("queues"))

    # No match, we don't know this scheduler
    return {}


def get_num_service_threads(line):
    items = line.split()
    idx1 = items.index("service_threads:")
    idx2 = items.index("blocking_threads:")
    dic_str = ' '.join(items[idx1 + 1:idx2])
    thread_dic = ast.literal_eval(dic_str)
    return sum(thread_dic.values())


def get_num_blocking_threads(line):
    items = line.split()
    idx1 = items.index("blocking_threads:")
    idx2 = idx1 + 1
    while '}' not in items[idx2]:
        idx2 += 1
        assert idx2 < len(items)
    dic_str = ' '.join(items[idx1 + 1:idx2 + 1])
    thread_dic = ast.literal_eval(dic_str)
    return sum(thread_dic.values())


def get_average_utilization(resource_log, resource_name):
    total_utilization = 0
    iterations = 0
    for line in open(resource_log):
        items = line.split()
        if items[1] != resource_name:
            continue
        utilization = float(items[7])
        total_utilization += utilization
        iterations += 1
    return total_utilization / iterations


def get_average_throughput(client_log, client_name, time_range=None):
    total_throughput = 0
    iterations = 0
    for line in open(client_log):
        items = line.split()
        if client_name not in items[1]:
            continue
        time = float(items[5])
        if time_range is not None and time < time_range[0]:
            continue
        if time_range is not None and time > time_range[1]:
            continue
        throughput = float(items[7])
        total_throughput += throughput
        iterations += 1
    return total_throughput / iterations


def get_average_latency(client_log, client_name):
    total_latency = 0
    iterations = 0
    for line in open(client_log):
        items = line.split()
        if client_name not in items[1]:
            continue
        if items[9] == "nan":
            continue
        latency = float(items[9])
        total_latency += latency
        iterations += 1
    return total_latency / iterations
